{"version":3,"file":"index.umd.js","sources":["../src/RouteDataContext.tsx","../src/types.ts","../src/Routes.tsx","../src/index.ts","../src/FetchData.ts"],"sourcesContent":["/* eslint camelcase: off */\n/* eslint @typescript-eslint/camelcase: off */\n\nimport React, { useEffect } from 'react';\nimport { createContainer } from 'react-tracked';\n\nconst noop = () => null;\n\nconst passDataProp = ({ data }: { data: object }) => [\n  data,\n  noop, // dummy update function, only used to notify updates\n] as const;\n\nconst {\n  Provider,\n  useUpdate,\n  useTrackedState,\n  useSelector,\n} = createContainer(passDataProp);\n\nconst SetNotify: React.FC<{\n  setNotify: (notify: () => void) => void;\n}> = ({ setNotify }) => {\n  const notify = useUpdate();\n  useEffect(() => {\n    setNotify(notify);\n  });\n  return null;\n};\n\nexport const RouteDataProvider: React.FC<{\n  data: object;\n  setNotify: (notify: () => void) => void;\n}> = ({ data, setNotify, children }) => (\n  <Provider data={data}>\n    <SetNotify setNotify={setNotify} />\n    {children}\n  </Provider>\n);\n\ntype UseTrackedState = <State>(opts: {\n  unstable_ignoreStateEquality?: boolean;\n}) => State;\n\nexport const useRouteData = () => (useTrackedState as UseTrackedState)({\n  // Because Suspendable by react-suspense-fetch is a mutable object,\n  // we need this special mode to handle it.\n  unstable_ignoreStateEquality: true,\n});\n\nexport const useRouteDataSelector = useSelector;\n","import { isValidElement, ReactElement } from 'react';\nimport { RouteMatch, PartialRouteObject, RouteObject } from 'react-router';\n\nexport type Match = Omit<RouteMatch, 'route'>;\n\ntype RouteWithElement = RouteObject & {\n  element: ReactElement;\n};\n\nexport const hasRouteElement = (\n  route: PartialRouteObject,\n): route is RouteWithElement => (\n  isValidElement((route as RouteWithElement).element)\n);\n","/* eslint react/no-children-prop: off */\n\nimport React, { useEffect, useState, useRef } from 'react';\nimport { Location } from 'history';\nimport {\n  useParams,\n  useResolvedLocation,\n  createRoutesFromChildren,\n  useRoutes as useRoutesOrig,\n  useLocationListen, // by fork\n  useLocation,\n  matchRoutes,\n  RouteMatch,\n  PartialRouteObject,\n  RouteObject,\n  createRoutesFromArray,\n} from 'react-router';\n\nimport { RouteDataProvider } from './RouteDataContext';\n\nimport { hasRouteElement, Match } from './types';\n\n// HACK because RouteContext is not exported.\nconst EMPTY_PATHNAME = { pathname: undefined };\nconst usePathname = () => useResolvedLocation(EMPTY_PATHNAME).pathname;\n\nconst useBasename = (basenameOrig: string) => {\n  const parentPathname = usePathname();\n  const basename = basenameOrig\n    ? `${parentPathname}/${basenameOrig}`.replace(/\\/\\/+/g, '/')\n    : parentPathname;\n  return basename;\n};\n\ntype RouteDataMap = { [path: string]: object };\ntype RouteNotifyMap = Map<string, () => void>;\n\nconst attachRouteData = (\n  routesOrig: RouteObject[],\n  routeDataMap: RouteDataMap,\n  routeNotifyMap?: RouteNotifyMap,\n) => routesOrig.map((route) => {\n  if (!hasRouteElement(route)) return route;\n  const { fetchData } = route.element.props as { fetchData: unknown };\n  if (typeof fetchData !== 'function') return route;\n  const routeData = routeDataMap[route.path];\n  const setNotify = (notify: () => void) => {\n    if (routeNotifyMap) {\n      routeNotifyMap.set(route.path, notify);\n    }\n  };\n  return {\n    ...route,\n    element: routeData && (\n      <RouteDataProvider data={routeData} setNotify={setNotify} children={route.element} />\n    ),\n  };\n});\n\nconst createRouteDataMap = (\n  matches: RouteMatch[] | null,\n  parentParams: { [key: string]: string },\n) => {\n  const map: RouteDataMap = {};\n  (matches || []).forEach((match: RouteMatch) => {\n    const { params, pathname, route } = match;\n    if (!route || !hasRouteElement(route)) return;\n    const { fetchData } = route.element.props as { fetchData: unknown };\n    if (typeof fetchData !== 'function') return;\n    const m: Match = {\n      params: { ...parentParams, ...params },\n      pathname,\n    };\n    const routeData = fetchData(m);\n    map[route.path] = routeData;\n  });\n  return map;\n};\n\nconst getCachedRouteDataMap = (basename: string) => {\n  try {\n    const cache = (window as unknown as {\n      __ROUTE_DATA_MAP_CACHE__: { [basename: string]: RouteDataMap };\n    }).__ROUTE_DATA_MAP_CACHE__;\n    if (!cache[basename]) {\n      cache[basename] = {};\n    }\n    return cache[basename];\n  } catch (e) {\n    return {} as RouteDataMap;\n  }\n};\n\nconst consumeCachedRouteDataMap = (basename: string) => {\n  try {\n    const cache = (window as unknown as {\n      __ROUTE_DATA_MAP_CACHE__: { [basename: string]: RouteDataMap };\n    }).__ROUTE_DATA_MAP_CACHE__;\n    if (cache[basename]) {\n      delete cache[basename];\n      return true;\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n};\n\n// for ssr\nconst isSsr = (\n  typeof window === 'undefined'\n  || typeof window.navigator === 'undefined'\n  || `${window.navigator.userAgent}`.includes('ServerSideRendering')\n);\n\nconst useRoutesSsr = (\n  partialRoutesOrig: PartialRouteObject[],\n  basenameOrig = '',\n) => {\n  const routesOrig = createRoutesFromArray(partialRoutesOrig);\n  const basename = useBasename(basenameOrig);\n  const parentParams = useParams();\n\n  const location = useLocation();\n  const matches = matchRoutes(routesOrig, location, basename);\n  const routeDataMap = getCachedRouteDataMap(basename);\n  if (Object.keys(routeDataMap).length === 0) {\n    Object.assign(routeDataMap, createRouteDataMap(matches, parentParams));\n  }\n\n  const routes = attachRouteData(routesOrig, routeDataMap);\n  return useRoutesOrig(routes, basenameOrig);\n};\n\nexport const useRoutes = isSsr ? useRoutesSsr : (\n  partialRoutesOrig: PartialRouteObject[],\n  basenameOrig = '',\n) => {\n  const routesOrig = createRoutesFromArray(partialRoutesOrig);\n  const listen = useLocationListen();\n  const basename = useBasename(basenameOrig);\n  const parentParams = useParams();\n\n  const [routeDataMap, setRouteDataMap] = useState<RouteDataMap>(\n    () => getCachedRouteDataMap(basename),\n  );\n  const routeNotifyMap = useRef<RouteNotifyMap>(new Map());\n\n  const ref = useRef<{\n    routesOrig: RouteObject[];\n    basename: string;\n    parentParams: { [key: string]: string };\n  }>();\n  // Should we useLayoutEffect here?\n  useEffect(() => {\n    ref.current = {\n      routesOrig,\n      basename,\n      parentParams,\n    };\n  });\n\n  useEffect(() => {\n    let map: RouteDataMap = {};\n    const unlisten = listen((location: Location) => {\n      if (consumeCachedRouteDataMap(ref.current?.basename || '')) {\n        // we assume hydration this time\n        return;\n      }\n      const matches = matchRoutes(\n        ref.current?.routesOrig || [],\n        location,\n        ref.current?.basename,\n      );\n      map = createRouteDataMap(matches || [], ref.current?.parentParams || {});\n      setRouteDataMap((prev) => {\n        if (Object.keys(prev).length === 0 && Object.keys(map).length === 0) {\n          // bail out\n          return prev;\n        }\n        return map;\n      });\n      Object.keys(map).forEach((path) => {\n        const notify = routeNotifyMap.current.get(path);\n        if (notify) notify();\n      });\n    });\n    return unlisten;\n  }, [listen]);\n\n  const routes = attachRouteData(routesOrig, routeDataMap, routeNotifyMap.current);\n  return useRoutesOrig(routes, basenameOrig);\n};\n\ntype Props = {\n  basename?: string;\n};\n\nexport const Routes: React.FC<Props> = ({\n  basename = '',\n  children,\n}) => {\n  const routes = createRoutesFromChildren(children);\n  return useRoutes(routes, basename);\n};\n","import { ComponentType } from 'react';\nimport {\n  Route as RouteOrig,\n  RouteProps,\n} from 'react-router';\n\nexport {\n  // components\n  MemoryRouter,\n  Navigate,\n  Outlet,\n  Router,\n  // hooks\n  useBlocker,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useLocationPending,\n  useLocationListen,\n  useMatch,\n  useNavigate,\n  useOutlet,\n  useParams,\n  useResolvedLocation,\n  // utils\n  createRoutesFromArray,\n  createRoutesFromChildren,\n  generatePath,\n  matchRoutes,\n  matchPath,\n  resolveLocation,\n} from 'react-router';\n\nexport {\n  BrowserRouter,\n  HashRouter,\n  Link,\n  NavLink,\n  Prompt,\n  usePrompt,\n  useSearchParams,\n  createSearchParams,\n} from 'react-router-dom';\n\nexport {\n  StaticRouter,\n} from 'react-router-dom/server';\n\nexport const Route = RouteOrig as ComponentType<RouteProps & { fetchData?: Function }>;\n\n/**\n * Routes for Suspense Render-as-You-Fetch\n *\n * Its usage is the same with react-router,\n * except that Route accepts `fetchData` prop.\n * Specify a function created by FetchData or FetchDataLazy.\n *\n * @example\n * import { Routes, Route } from 'react-suspense-router';\n *\n * const MyRoutes = () => (\n *   <Routes>\n *     <Route path=\"/\" element={<Index />} />\n *     <Route path=\"/double/:number\" element={<Double />} fetchData={fetchDouble} />\n *   </Routes>\n * );\n */\nexport { Routes } from './Routes';\n\n/**\n * useRoutes for Suspense Render-as-You-Fetch\n *\n * Its usage is the same with react-router,\n * except that Route accepts `fetchData` prop.\n * Specify a function created by FetchData or FetchDataLazy.\n */\nexport { useRoutes } from './Routes';\n\n/**\n * FetchData\n *\n * This will wrap an async function and create `fetchData`\n * that canbe passed to `fetchData` prop in <Route>.\n *\n * @example\n * import { FetchData, Route } from 'react-suspense-router';\n *\n * const fetchDouble = FetchData(async (match) => {\n *   await sleep(1000);\n *   return { result: match.params.number * 2 };\n * });\n *\n * <Route path=\"...\" element={...} fetchData={fetchDouble} />\n */\nexport { FetchData } from './FetchData';\n\n/**\n * FetchDataLazy\n *\n * This is lazy loading version of FetchData.\n * It will be used like React.lazy, but for route data.\n *\n * @example\n * import { FetchDataLazy, Route } from 'react-suspense-router';\n *\n * const fetchUserData = FetchDataLazy(() => import('./pages/User.data'));\n *\n * <Route path=\"...\" element={...} fetchData={fetchUserData} />\n */\nexport { FetchDataLazy } from './FetchData';\n\n/**\n * useRouteData hook\n *\n * This will return route data in components inside a route.\n * It utilizes proxy-based tracking by React Tracked.\n *\n * @example\n * import { useRouteData } from 'react-suspense-fetch';\n *\n * const FirstName = () => {\n *   const userData = useRouteData();\n *   return <div>userData.firstName</div>\n * };\n */\nexport { useRouteData } from './RouteDataContext';\n\n/**\n * useRouteDataSelector hook\n *\n * This will return route data in components inside a route.\n * It takes a selector function.\n * Use this if proxy-based tracking doesn't work.\n *\n * @example\n * import { useRouteDataSelector } from 'react-suspense-fetch';\n *\n * const selectFirstName = data => data.firstName;\n * const FirstName = () => {\n *   const firstName = useRouteDataSelector(selectFirstName);\n *   return <div>firstName</div>\n * };\n */\nexport { useRouteDataSelector } from './RouteDataContext';\n\n// types\nexport { Match } from './types';\n","import { prepare, run, prefetch } from 'react-suspense-fetch';\n\nimport { Match } from './types';\n\ntype FetchFunc<T extends object> = (m: Match) => Promise<T>;\n\nexport const FetchData = <T extends object>(fetchFunc: FetchFunc<T>) => {\n  const fetchData = (match: Match) => prefetch(fetchFunc, match);\n  return fetchData;\n};\n\nexport const FetchDataLazy = <T extends object>(\n  factory: () => Promise<{ default: FetchFunc<T> }>,\n) => {\n  const preparedFetcher = prepare(factory);\n  const invokeFetcher = async (\n    [fetchData, match]: readonly [FetchFunc<T>, Match],\n  ) => fetchData(match);\n  const fetchDataLazy = (match: Match) => {\n    run(preparedFetcher, null);\n    return prefetch(\n      invokeFetcher,\n      [preparedFetcher, match] as const,\n      (source) => [\n        source[0].default, // can suspend\n        source[1],\n      ] as const,\n    );\n  };\n  return fetchDataLazy;\n};\n"],"names":["noop","createContainer","data","Provider","useUpdate","useTrackedState","SetNotify","setNotify","notify","useEffect","RouteDataProvider","children","React","useRouteDataSelector","useSelector","hasRouteElement","route","isValidElement","element","EMPTY_PATHNAME","pathname","undefined","useBasename","basenameOrig","parentPathname","useResolvedLocation","replace","attachRouteData","routesOrig","routeDataMap","routeNotifyMap","map","props","fetchData","routeData","path","set","createRouteDataMap","matches","parentParams","forEach","match","params","getCachedRouteDataMap","basename","cache","window","__ROUTE_DATA_MAP_CACHE__","e","useRoutes","navigator","userAgent","includes","partialRoutesOrig","createRoutesFromArray","useParams","location","useLocation","matchRoutes","Object","keys","length","assign","routes","useRoutesOrig","listen","useLocationListen","useState","setRouteDataMap","useRef","Map","ref","current","consumeCachedRouteDataMap","_ref$current3","prev","get","Route","RouteOrig","fetchFunc","prefetch","factory","preparedFetcher","prepare","invokeFetcher","run","source","createRoutesFromChildren","unstable_ignoreStateEquality"],"mappings":"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"}