{"version":3,"file":"index.esm.js","sources":["../src/HistoryContext.tsx","../src/SuspensePendingContext.tsx","../src/BrowserRouter.tsx","../src/RouteDataContext.ts","../src/RouteWrapper.tsx","../src/Routes.tsx","../src/types.ts","../src/LazyFetcher.ts"],"sourcesContent":["import React, { createContext, useContext } from 'react';\n\nimport { History } from './types';\n\nconst HistoryContext = createContext<History | null>(null);\n\ntype Props = {\n  history: History;\n};\n\nexport const HistoryProvider: React.FC<Props> = ({\n  history,\n  children,\n}) => (\n  <HistoryContext.Provider value={history}>\n    {children}\n  </HistoryContext.Provider>\n);\n\nexport const useHistory = () => {\n  const history = useContext(HistoryContext);\n  if (!history) throw new Error('missing <HistoryContext>');\n  return history;\n};\n","import React, { createContext, useContext } from 'react';\n\nconst SuspensePendingContext = createContext(false);\n\ntype Props = {\n  suspensePending: boolean;\n};\n\nexport const SuspensePendingProvider: React.FC<Props> = ({\n  suspensePending,\n  children,\n}) => (\n  <SuspensePendingContext.Provider value={suspensePending}>\n    {children}\n  </SuspensePendingContext.Provider>\n);\n\nexport const useSuspensePending = () => useContext(SuspensePendingContext);\n","// eslint-disable-next-line spaced-comment\n/// <reference types=\"react/experimental\" />\n\nimport React, {\n  TransitionStartFunction,\n  useRef,\n  useTransition,\n} from 'react';\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport { Router } from 'react-router';\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport { createBrowserHistory } from 'history';\n\nimport { History, HistoryEvent } from './types';\nimport { HistoryProvider } from './HistoryContext';\nimport { SuspensePendingProvider } from './SuspensePendingContext';\n\ntype Props = {\n  timeout?: number;\n  window?: unknown;\n};\n\nconst wrapHistory = (startTransiton: TransitionStartFunction) => (history: History) => {\n  const listen = (listener: (e: HistoryEvent) => void) => {\n    const unlisten = history.listen((e: HistoryEvent) => {\n      startTransiton(() => {\n        listener(e);\n      });\n    });\n    return unlisten;\n  };\n  return { ...history, listen };\n};\n\nexport const BrowserRouter: React.FC<Props> = ({\n  timeout,\n  window,\n  children,\n}) => {\n  const [startTransiton, isPending] = useTransition(timeout ? { timeoutMs: timeout } : null);\n  const history = useRef<History>();\n  if (!history.current) {\n    history.current = wrapHistory(startTransiton)(createBrowserHistory({ window }));\n  }\n  return (\n    <HistoryProvider history={history.current}>\n      <SuspensePendingProvider suspensePending={isPending}>\n        <Router history={history.current} timeout={timeout}>\n          {children}\n        </Router>\n      </SuspensePendingProvider>\n    </HistoryProvider>\n  );\n};\n\nexport default BrowserRouter;\n","/* eslint camelcase: off */\n/* eslint @typescript-eslint/camelcase: off */\n\nimport { createContainer } from 'react-tracked';\n\nconst passDataProp = ({ data }: { data: object }) => [\n  data,\n  null, // we don't use useUpdate\n] as const;\n\nconst {\n  Provider,\n  useTrackedState,\n  useSelector,\n} = createContainer(passDataProp);\n\nexport const RouteDataProvider = Provider;\n\ntype UseTrackedState = <State>(opts: {\n  unstable_ignoreStateEquality?: boolean;\n}) => State;\n\nexport const useRouteData = () => (useTrackedState as UseTrackedState)({\n  // Because Suspendable by react-suspense-fetch is a mutable object,\n  // we need this special mode to handle it.\n  unstable_ignoreStateEquality: true,\n});\n\nexport const useRouteDataSelector = useSelector;\n","import React, { useRef, useState, useEffect } from 'react';\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport { matchRoutes } from 'react-router';\n\nimport { RouteDataProvider } from './RouteDataContext';\nimport { match as Match, History, HistoryEvent } from './types';\n\nconst INITIALIZED_MAP = Symbol('INITIALIZED_MAP');\n\n// HACK we mutate history for global cache\nconst getInitializedMap = <Key extends unknown, Value>(history: History) => {\n  const hackedHistory = history as {\n    [INITIALIZED_MAP]?: Map<Key, Value>;\n  };\n  let initializedMap = hackedHistory[INITIALIZED_MAP];\n  if (!initializedMap) {\n    initializedMap = new Map();\n    hackedHistory[INITIALIZED_MAP] = initializedMap;\n  }\n  return initializedMap;\n};\n\ntype FetchData = (m: Match) => object;\n\nconst getInitialRouteData = (\n  history: History,\n  fetchData: FetchData,\n  path: string,\n  basename: string,\n  caseSensitive: boolean,\n  match: Match,\n) => {\n  type Item = {\n    data: object;\n    commit: () => void;\n    cleanup: () => void;\n  };\n  const initializedMap = getInitializedMap<string, Item>(history);\n  const key = JSON.stringify({\n    path,\n    basename,\n    caseSensitive,\n    match,\n  }); // HACK we need a consistent key in concurrent mode\n  if (!initializedMap.has(key)) {\n    const data = fetchData(match);\n    const timer = setTimeout(() => {\n      initializedMap.delete(key);\n    }, 30 * 1000); // HACK 30 sec cleanup timeout\n    const commit = () => {\n      clearTimeout(timer);\n    };\n    const cleanup = () => {\n      initializedMap.delete(key);\n      clearTimeout(timer);\n    };\n    initializedMap.set(key, { data, commit, cleanup });\n  }\n  return initializedMap.get(key) as Item;\n};\n\ntype Props = {\n  history: History;\n  routePath: string;\n  basename: string;\n  caseSensitive: boolean;\n  fetchData: FetchData;\n  match: Match;\n};\n\nexport const RouteWrapper: React.FC<Props> = ({\n  history,\n  routePath,\n  basename,\n  caseSensitive,\n  fetchData,\n  match,\n  children,\n}) => {\n  const commit = useRef<() => void>();\n  const cleanup = useRef<() => void>();\n  const [routeData, setRouteData] = useState<object>(() => {\n    const item = getInitialRouteData(\n      history,\n      fetchData,\n      routePath,\n      basename,\n      caseSensitive,\n      match,\n    );\n    commit.current = item.commit;\n    cleanup.current = item.cleanup;\n    return item.data;\n  });\n  useEffect(() => {\n    const unlisten = history.listen(({ location }: HistoryEvent) => {\n      if (commit.current) commit.current();\n      const matches = matchRoutes([{ path: routePath }], location, basename, caseSensitive);\n      if (matches && matches.length) {\n        // TODO we do not have parentParams here\n        const m: Match = {\n          params: matches[0].params,\n          pathname: matches[0].pathname,\n        };\n        setRouteData(fetchData(m));\n        if (cleanup.current) cleanup.current();\n      }\n    });\n    // FIXME route could be change before this effect is handled?\n    return () => {\n      if (cleanup.current) cleanup.current();\n      unlisten();\n    };\n  }, [history, routePath, basename, caseSensitive, fetchData]);\n  return (\n    <RouteDataProvider data={routeData}>\n      {children}\n    </RouteDataProvider>\n  );\n};\n\nexport default RouteWrapper;\n","import React, { createElement, useMemo } from 'react';\nimport {\n  useParams,\n  useResolvedLocation,\n  createRoutesFromChildren,\n  useRoutes as useRoutesOrig,\n  useLocation,\n  matchRoutes,\n  // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n  // @ts-ignore\n} from 'react-router';\n\nimport { Route, match as Match, hasRouteElement } from './types';\nimport { RouteWrapper } from './RouteWrapper';\nimport { useHistory } from './HistoryContext';\n\n// HACK because RouteContext is not exported.\nconst EMPTY_PATHNAME = { pathname: null };\nconst usePathname = () => useResolvedLocation(EMPTY_PATHNAME).pathname;\n\nexport const useRoutes = (\n  routesOrig: Route[],\n  basenameOrig = '',\n  caseSensitive = false,\n) => {\n  const history = useHistory();\n  const location = useLocation();\n  const parentPathname = usePathname();\n  const parentParams = useParams();\n\n  const basename = basenameOrig\n    ? `${parentPathname}/${basenameOrig}`.replace(/\\/\\/+/g, '/')\n    : parentPathname;\n\n  const matches = useMemo(\n    () => matchRoutes(routesOrig, location, basename, caseSensitive),\n    [routesOrig, location, basename, caseSensitive],\n  );\n\n  const routes = [...routesOrig];\n  (matches || []).forEach((match: Match & { route?: Route }) => {\n    if (!match.route) return;\n    const routeIndex = routes.indexOf(match.route);\n    if (routeIndex === -1) return;\n    const route = routes[routeIndex];\n    if (!hasRouteElement(route)) return;\n    const { fetchData } = route.element.props;\n    if (!fetchData) return;\n    const params = { ...parentParams, ...match.params };\n    const element = createElement(RouteWrapper, {\n      history,\n      routePath: route.path,\n      basename,\n      caseSensitive,\n      fetchData,\n      match: { params, pathname: match.pathname },\n    }, route.element);\n    routes[routeIndex] = { ...route, element };\n  });\n\n  return useRoutesOrig(routes, basenameOrig, caseSensitive);\n};\n\ntype Props = {\n  basename?: string;\n  caseSensitive?: boolean;\n};\n\nexport const Routes: React.FC<Props> = ({\n  basename = '',\n  caseSensitive = false,\n  children,\n}) => {\n  const routes = createRoutesFromChildren(children);\n  return useRoutes(routes, basename, caseSensitive);\n};\n","import { ReactElement, ReactNode } from 'react';\n\ntype RouteWithElement = {\n  path: string;\n  element: ReactElement;\n  children: ReactNode;\n};\n\ntype RouteWithRedirectTo = {\n  path: string;\n  redirectTo: string;\n};\n\nexport type Route = RouteWithElement | RouteWithRedirectTo;\n\nexport const hasRouteElement = (route: Route): route is RouteWithElement => (\n  !!(route as RouteWithElement).element\n);\n\nexport type match<Params extends { [K in keyof Params]?: string } = {}> = {\n  params: Params;\n  pathname: string;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type History = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type HistoryEvent = any;\n","import { prepare, run, prefetch } from 'react-suspense-fetch';\n\nimport { match as Match } from './types';\n\nexport const LazyFetcher = <T extends object, P>(\n  factory: () => Promise<{ default: (m: Match<P>) => Promise<T> }>,\n) => {\n  const preparedFetcher = prepare(factory);\n  const invokeFetcher = async (\n    [fetcher, match]: readonly [(m: Match<P>) => Promise<T>, Match<P>],\n  ) => fetcher(match);\n  return (match: Match<P>) => {\n    run(preparedFetcher, null);\n    return prefetch(\n      invokeFetcher,\n      [preparedFetcher, match] as const,\n      (source) => [\n        source[0].default, // can suspend\n        source[1],\n      ] as const,\n    );\n  };\n};\n\nexport default LazyFetcher;\n"],"names":["HistoryContext","createContext","HistoryProvider","React","Provider","value","history","children","SuspensePendingContext","SuspensePendingProvider","suspensePending","useSuspensePending","useContext","BrowserRouter","timeout","window","useTransition","timeoutMs","startTransiton","isPending","useRef","current","listen","listener","e","wrapHistory","createBrowserHistory","Router","createContainer","data","useTrackedState","RouteDataProvider","useRouteData","unstable_ignoreStateEquality","useRouteDataSelector","useSelector","INITIALIZED_MAP","Symbol","RouteWrapper","routePath","basename","caseSensitive","fetchData","match","commit","cleanup","useState","item","path","initializedMap","hackedHistory","Map","getInitializedMap","key","JSON","stringify","has","timer","setTimeout","set","clearTimeout","get","getInitialRouteData","routeData","setRouteData","useEffect","unlisten","location","matches","matchRoutes","length","params","pathname","EMPTY_PATHNAME","useRoutes","routesOrig","basenameOrig","Error","useHistory","useLocation","parentPathname","useResolvedLocation","parentParams","useParams","replace","useMemo","routes","forEach","route","routeIndex","indexOf","element","hasRouteElement","props","createElement","useRoutesOrig","Routes","createRoutesFromChildren","LazyFetcher","factory","preparedFetcher","prepare","invokeFetcher","fetcher","run","prefetch","source"],"mappings":"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"}