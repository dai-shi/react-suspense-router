{"version":3,"file":"index.esm.js","sources":["../node_modules/history/history.js","../src/StaticRouter.tsx","../src/types.ts","../src/RouteDataContext.ts","../src/Routes.tsx","../src/FetchData.ts"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';var w=\"production\"!==process.env.NODE_ENV?function(a){return Object.freeze(a)}:function(a){return a};function x(a,f){if(!a){\"undefined\"!==typeof console&&console.warn(f);try{throw Error(f);}catch(h){}}}function y(a){a.preventDefault();a.returnValue=\"\"}function z(){var a=[];return{get length(){return a.length},push:function(f){a.push(f);return function(){a=a.filter(function(a){return a!==f})}},call:function(f){a.forEach(function(a){return a&&a(f)})}}}\nfunction A(){return Math.random().toString(36).substr(2,8)}function C(a){var f=a.pathname,h=a.search;a=a.hash;return(void 0===f?\"/\":f)+(void 0===h?\"\":h)+(void 0===a?\"\":a)}function D(a){var f={};if(a){var h=a.indexOf(\"#\");0<=h&&(f.hash=a.substr(h),a=a.substr(0,h));h=a.indexOf(\"?\");0<=h&&(f.search=a.substr(h),a=a.substr(0,h));a&&(f.pathname=a)}return f}\nvar createBrowserHistory=function(a){function f(){var a=k.location,e=g.state||{};return[e.idx,w({pathname:a.pathname,search:a.search,hash:a.hash,state:e.usr||null,key:e.key||\"default\"})]}function h(a){return\"string\"===typeof a?a:C(a)}function r(a,e){void 0===e&&(e=null);return w(_extends({},m,{},\"string\"===typeof a?D(a):a,{state:e,key:A()}))}function u(a){n=a;a=f();p=a[0];m=a[1];c.call({action:n,location:m})}function v(a,e){function c(){v(a,e)}var B=r(a,e);if(!b.length||(b.call({action:\"PUSH\",\nlocation:B,retry:c}),!1)){var d=[{usr:B.state,key:B.key,idx:p+1},h(B)];B=d[0];d=d[1];try{g.pushState(B,null,d)}catch(E){k.location.assign(d)}u(\"PUSH\")}}function t(a,e){function c(){t(a,e)}var d=r(a,e);b.length&&(b.call({action:\"REPLACE\",location:d,retry:c}),1)||(d=[{usr:d.state,key:d.key,idx:p},h(d)],g.replaceState(d[0],null,d[1]),u(\"REPLACE\"))}function l(a){g.go(a)}a=(void 0===a?{}:a).window;var k=void 0===a?document.defaultView:a,g=k.history,q=null;k.addEventListener(\"popstate\",function(){if(q)b.call(q),\nq=null;else{var a=f(),e=a[0];a=a[1];if(b.length)if(null!=e){var c=p-e;c&&(q={action:\"POP\",location:a,retry:function(){l(-1*c)}},l(c))}else\"production\"!==process.env.NODE_ENV?x(!1,\"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\"):void 0;else u(\"POP\")}});var n=\n\"POP\";a=f();var p=a[0],m=a[1],b=z(),c=z();null==p&&(p=0,g.replaceState(_extends({},g.state,{idx:p}),null));return{get action(){return n},get location(){return m},createHref:h,push:v,replace:t,go:l,back:function(){l(-1)},forward:function(){l(1)},listen:function(a){return c.push(a)},block:function(a){var e=b.push(a);1===b.length&&k.addEventListener(\"beforeunload\",y);return function(){e();b.length||k.removeEventListener(\"beforeunload\",y)}}}};\nvar createHashHistory=function(a){function f(){var a=D(g.location.hash.substr(1)),b=a.pathname,c=a.search;a=a.hash;var d=q.state||{};return[d.idx,w({pathname:void 0===b?\"/\":b,search:void 0===c?\"\":c,hash:void 0===a?\"\":a,state:d.usr||null,key:d.key||\"default\"})]}function h(){if(n)c.call(n),n=null;else{var a=f(),b=a[0];a=a[1];if(c.length)if(null!=b){var d=m-b;d&&(n={action:\"POP\",location:a,retry:function(){k(-1*d)}},k(d))}else\"production\"!==process.env.NODE_ENV?x(!1,\"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\"):\nvoid 0;else v(\"POP\")}}function r(a){var b=document.querySelector(\"base\"),e=\"\";b&&b.getAttribute(\"href\")&&(b=g.location.href,e=b.indexOf(\"#\"),e=-1===e?b:b.slice(0,e));return e+\"#\"+(\"string\"===typeof a?a:C(a))}function u(a,c){void 0===c&&(c=null);return w(_extends({},b,{},\"string\"===typeof a?D(a):a,{state:c,key:A()}))}function v(a){p=a;a=f();m=a[0];b=a[1];d.call({action:p,location:b})}function t(a,b){function d(){t(a,b)}var e=u(a,b);\"production\"!==process.env.NODE_ENV?x(\"/\"===e.pathname.charAt(0),\"Relative pathnames are not supported in hash history.push(\"+\nJSON.stringify(a)+\")\"):void 0;if(!c.length||(c.call({action:\"PUSH\",location:e,retry:d}),!1)){var f=[{usr:e.state,key:e.key,idx:m+1},r(e)];e=f[0];f=f[1];try{q.pushState(e,null,f)}catch(F){g.location.assign(f)}v(\"PUSH\")}}function l(a,b){function e(){l(a,b)}var d=u(a,b);\"production\"!==process.env.NODE_ENV?x(\"/\"===d.pathname.charAt(0),\"Relative pathnames are not supported in hash history.replace(\"+JSON.stringify(a)+\")\"):void 0;c.length&&(c.call({action:\"REPLACE\",location:d,retry:e}),1)||(d=[{usr:d.state,\nkey:d.key,idx:m},r(d)],q.replaceState(d[0],null,d[1]),v(\"REPLACE\"))}function k(a){q.go(a)}a=(void 0===a?{}:a).window;var g=void 0===a?document.defaultView:a,q=g.history,n=null;g.addEventListener(\"popstate\",h);g.addEventListener(\"hashchange\",function(){var a=f()[1];C(a)!==C(b)&&h()});var p=\"POP\";a=f();var m=a[0],b=a[1],c=z(),d=z();null==m&&(m=0,q.replaceState(_extends({},q.state,{idx:m}),null));return{get action(){return p},get location(){return b},createHref:r,push:t,replace:l,go:k,back:function(){k(-1)},\nforward:function(){k(1)},listen:function(a){return d.push(a)},block:function(a){var b=c.push(a);1===c.length&&g.addEventListener(\"beforeunload\",y);return function(){b();c.length||g.removeEventListener(\"beforeunload\",y)}}}};\nvar createMemoryHistory=function(a){function f(a,c){void 0===c&&(c=null);return w(_extends({},n,{},\"string\"===typeof a?D(a):a,{state:c,key:A()}))}function h(a,c,d){return!p.length||(p.call({action:a,location:c,retry:d}),!1)}function r(a,c){q=a;n=c;m.call({action:q,location:n})}function u(a,c){var b=f(a,c);\"production\"!==process.env.NODE_ENV?x(\"/\"===n.pathname.charAt(0),\"Relative pathnames are not supported in memory history.push(\"+JSON.stringify(a)+\")\"):void 0;h(\"PUSH\",b,function(){u(a,c)})&&(g+=\n1,k.splice(g,k.length,b),r(\"PUSH\",b))}function v(a,c){var b=f(a,c);\"production\"!==process.env.NODE_ENV?x(\"/\"===n.pathname.charAt(0),\"Relative pathnames are not supported in memory history.replace(\"+JSON.stringify(a)+\")\"):void 0;h(\"REPLACE\",b,function(){v(a,c)})&&(k[g]=b,r(\"REPLACE\",b))}function t(a){var b=Math.min(Math.max(g+a,0),k.length-1),d=k[b];h(\"POP\",d,function(){t(a)})&&(g=b,r(\"POP\",d))}var l=void 0===a?{}:a;a=l.initialEntries;l=l.initialIndex;l=void 0===l?0:l;var k=(void 0===a?[\"/\"]:a).map(function(a){var b=\nw(_extends({pathname:\"/\",search:\"\",hash:\"\",state:null,key:A()},\"string\"===typeof a?D(a):a));\"production\"!==process.env.NODE_ENV?x(\"/\"===b.pathname.charAt(0),\"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \"+JSON.stringify(a)+\")\"):void 0;return b}),g=Math.min(Math.max(l,0),k.length-1),q=\"POP\",n=k[g],p=z(),m=z();return{get index(){return g},get action(){return q},get location(){return n},createHref:function(a){return\"string\"===typeof a?a:C(a)},push:u,\nreplace:v,go:t,back:function(){t(-1)},forward:function(){t(1)},listen:function(a){return m.push(a)},block:function(a){return p.push(a)}}};var createPath=C;var parsePath=D;export{createBrowserHistory,createHashHistory,createMemoryHistory,createPath,parsePath};\n//# sourceMappingURL=history.js.map\n","// https://github.com/ReactTraining/react-router/pull/7126\n// Temporary code until the new release is published.\n\n/* eslint-disable */\n// @ts-nocheck\nimport { Router } from 'react-router';\nimport { createPath, parsePath } from 'history';\nimport React from 'react';\n\nconst __DEV__ = true;\n\nexport function StaticRouter({ children, context = {}, location: loc = '/' }) {\n  if (typeof loc === 'string') loc = parsePath(loc);\n\n  let action = 'POP';\n  let location = {\n    pathname: loc.pathname || '/',\n    search: loc.search || '',\n    hash: loc.hash || '',\n    state: loc.state || null,\n    key: loc.key || 'default'\n  };\n\n  let mockHistory = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    push(location, state) {\n      let url = createPath(location);\n\n      if (__DEV__) {\n        // A PUSH is not technically valid in a static context because we can't\n        // push a new URL onto the history stack in a stateless environment. They\n        // most likely want a regular redirect so just warn them and carry on.\n        console.warn(\n          `You cannot perform a PUSH with a static router. You probably want a REPLACE instead.` +\n            `\\n\\nTo avoid this warning, find the element that is calling \\`navigate(\"${url}\")\\`` +\n            ` and change it to \\`navigate(\"${url}\", { replace: true })\\`. This could also be` +\n            ` caused by rendering a \\`<Navigate to={\"${url}\"} />\\` on the server. In that` +\n            ` case, just add a \\`replace: true\\` prop to do a redirect instead.`\n        );\n      }\n\n      context.url = url;\n      context.state = state;\n    },\n    replace(location, state) {\n      let url = createPath(location);\n      context.url = url;\n      context.state = state;\n    },\n    go(n) {\n      throw new Error(\n        `You cannot perform ${n === -1 ? 'GO BACK' : `GO(${n})`} on the ` +\n          `server because it is a stateless environment. This error was probably ` +\n          `triggered when you did a \\`navigate(${n})\\` somewhere in your app.`\n      );\n    },\n    listen() {},\n    block() {},\n    createHref(location) {\n      return createPath(location);\n    }\n  };\n\n  return <Router children={children} history={mockHistory} />;\n}\n","import { ReactElement, ReactNode } from 'react';\n\ntype RouteWithElement = {\n  path: string;\n  element: ReactElement;\n  children: ReactNode;\n};\n\ntype RouteWithRedirectTo = {\n  path: string;\n  redirectTo: string;\n};\n\nexport type Route = RouteWithElement | RouteWithRedirectTo;\n\nexport const hasRouteElement = (route: Route): route is RouteWithElement => (\n  !!(route as RouteWithElement).element\n);\n\nexport type match<Params extends { [K in keyof Params]?: string } = {}> = {\n  params: Params;\n  pathname: string;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Location = any;\n","/* eslint camelcase: off */\n/* eslint @typescript-eslint/camelcase: off */\n\nimport { createContainer } from 'react-tracked';\n\nconst passDataProp = ({ data }: { data: object }) => [\n  data,\n  null, // we don't use useUpdate\n] as const;\n\nconst {\n  Provider,\n  useTrackedState,\n  useSelector,\n} = createContainer(passDataProp);\n\nexport const RouteDataProvider = Provider;\n\ntype UseTrackedState = <State>(opts: {\n  unstable_ignoreStateEquality?: boolean;\n}) => State;\n\nexport const useRouteData = () => (useTrackedState as UseTrackedState)({\n  // Because Suspendable by react-suspense-fetch is a mutable object,\n  // we need this special mode to handle it.\n  unstable_ignoreStateEquality: true,\n});\n\nexport const useRouteDataSelector = useSelector;\n","/* eslint react/no-children-prop: off */\n\nimport React, { useEffect, useState, useRef } from 'react';\nimport {\n  useParams,\n  useResolvedLocation,\n  createRoutesFromChildren,\n  useRoutes as useRoutesOrig,\n  useListen, // by fork\n  useLocation,\n  matchRoutes,\n  // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n  // @ts-ignore\n} from 'react-router';\n\nimport {\n  Route,\n  hasRouteElement,\n  match as Match,\n  Location,\n} from './types';\nimport { RouteDataProvider } from './RouteDataContext';\n\n// HACK because RouteContext is not exported.\nconst EMPTY_PATHNAME = { pathname: null };\nconst usePathname = () => useResolvedLocation(EMPTY_PATHNAME).pathname;\n\nconst useBasename = (basenameOrig: string) => {\n  const parentPathname = usePathname();\n  const basename = basenameOrig\n    ? `${parentPathname}/${basenameOrig}`.replace(/\\/\\/+/g, '/')\n    : parentPathname;\n  return basename;\n};\n\ntype RouteDataMap = { [path: string]: object };\n\nconst attachRouteData = (\n  routesOrig: Route[],\n  routeDataMap: RouteDataMap,\n) => routesOrig.map((route) => {\n  if (!hasRouteElement(route)) return route;\n  const { fetchData } = route.element.props;\n  if (!fetchData) return route;\n  const routeData = routeDataMap[route.path];\n  return {\n    ...route,\n    element: routeData && (\n      <RouteDataProvider data={routeData} children={route.element} />\n    ),\n  };\n});\n\nconst createRouteDataMap = (\n  matches: (Match & { route?: Route })[],\n  parentParams: { [key: string]: string },\n) => {\n  const map: RouteDataMap = {};\n  (matches || []).forEach((match: Match & { route?: Route }) => {\n    const { params, pathname, route } = match;\n    if (!route || !hasRouteElement(route)) return;\n    const { fetchData } = route.element.props;\n    if (!fetchData) return;\n    const m: Match = {\n      params: { ...parentParams, ...params },\n      pathname,\n    };\n    const routeData = fetchData(m);\n    map[route.path] = routeData;\n  });\n  return map;\n};\n\nconst getCachedRouteDataMap = (basename: string) => {\n  try {\n    const cache = (window as unknown as {\n      __ROUTE_DATA_MAP_CACHE__: { [basename: string]: RouteDataMap };\n    }).__ROUTE_DATA_MAP_CACHE__;\n    if (!cache[basename]) {\n      cache[basename] = {};\n    }\n    return cache[basename];\n  } catch (e) {\n    return {} as RouteDataMap;\n  }\n};\n\nconst consumeCachedRouteDataMap = (basename: string) => {\n  try {\n    const cache = (window as unknown as {\n      __ROUTE_DATA_MAP_CACHE__: { [basename: string]: RouteDataMap };\n    }).__ROUTE_DATA_MAP_CACHE__;\n    if (cache[basename]) {\n      delete cache[basename];\n      return true;\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n};\n\n// for ssr\nconst isSsr = (\n  typeof window === 'undefined'\n  || typeof window.navigator === 'undefined'\n  || `${window.navigator.userAgent}`.includes('ServerSideRendering')\n);\n\nconst useRoutesSsr = (\n  routesOrig: Route[],\n  basenameOrig = '',\n  caseSensitive = false,\n) => {\n  const basename = useBasename(basenameOrig);\n  const parentParams = useParams();\n\n  const location = useLocation();\n  const matches = matchRoutes(routesOrig, location, basename, caseSensitive);\n  const routeDataMap = getCachedRouteDataMap(basename);\n  if (Object.keys(routeDataMap).length === 0) {\n    Object.assign(routeDataMap, createRouteDataMap(matches, parentParams));\n  }\n\n  const routes = attachRouteData(routesOrig, routeDataMap);\n  return useRoutesOrig(routes, basenameOrig, caseSensitive);\n};\n\nexport const useRoutes = isSsr ? useRoutesSsr : (\n  routesOrig: Route[],\n  basenameOrig = '',\n  caseSensitive = false,\n) => {\n  const listen = useListen();\n  const basename = useBasename(basenameOrig);\n  const parentParams = useParams();\n\n  const [routeDataMap, setRouteDataMap] = useState<RouteDataMap>(\n    () => getCachedRouteDataMap(basename),\n  );\n\n  const ref = useRef<{\n    routesOrig: Route[];\n    basename: string;\n    caseSensitive: boolean;\n    parentParams: { [key: string]: string };\n  }>();\n  // Should we useLayoutEffect here?\n  useEffect(() => {\n    ref.current = {\n      routesOrig,\n      basename,\n      caseSensitive,\n      parentParams,\n    };\n  });\n\n  useEffect(() => {\n    let map: RouteDataMap = {};\n    const unlisten = listen((location: Location) => {\n      if (consumeCachedRouteDataMap(ref.current?.basename || '')) {\n        // we assume hydration this time\n        return;\n      }\n      const matches = matchRoutes(\n        ref.current?.routesOrig,\n        location,\n        ref.current?.basename,\n        ref.current?.caseSensitive,\n      );\n      map = createRouteDataMap(matches || [], ref.current?.parentParams || {});\n      setRouteDataMap((prev) => {\n        if (Object.keys(prev).length === 0 && Object.keys(map).length === 0) {\n          // bail out\n          return prev;\n        }\n        return map;\n      });\n    });\n    return unlisten;\n  }, [listen]);\n\n  const routes = attachRouteData(routesOrig, routeDataMap);\n  return useRoutesOrig(routes, basenameOrig, caseSensitive);\n};\n\ntype Props = {\n  basename?: string;\n  caseSensitive?: boolean;\n};\n\nexport const Routes: React.FC<Props> = ({\n  basename = '',\n  caseSensitive = false,\n  children,\n}) => {\n  const routes = createRoutesFromChildren(children);\n  return useRoutes(routes, basename, caseSensitive);\n};\n","import { prepare, run, prefetch } from 'react-suspense-fetch';\n\nimport { match as Match } from './types';\n\ntype FetchFunc<T extends object, P> = (m: Match<P>) => Promise<T>;\n\nexport const FetchData = <T extends object, P>(fetchFunc: FetchFunc<T, P>) => {\n  const fetchData = (match: Match<P>) => prefetch(fetchFunc, match);\n  return fetchData;\n};\n\nexport const FetchDataLazy = <T extends object, P>(\n  factory: () => Promise<{ default: FetchFunc<T, P> }>,\n) => {\n  const preparedFetcher = prepare(factory);\n  const invokeFetcher = async (\n    [fetchData, match]: readonly [FetchFunc<T, P>, Match<P>],\n  ) => fetchData(match);\n  const fetchDataLazy = (match: Match<P>) => {\n    run(preparedFetcher, null);\n    return prefetch(\n      invokeFetcher,\n      [preparedFetcher, match] as const,\n      (source) => [\n        source[0].default, // can suspend\n        source[1],\n      ] as const,\n    );\n  };\n  return fetchDataLazy;\n};\n"],"names":["process","createPath","a","f","pathname","h","search","hash","StaticRouter","children","context","location","loc","indexOf","substr","parsePath","state","key","React","Router","history","action","push","url","console","warn","replace","go","n","Error","listen","block","createHref","hasRouteElement","route","element","createContainer","data","useTrackedState","RouteDataProvider","Provider","useRouteData","unstable_ignoreStateEquality","useRouteDataSelector","useSelector","EMPTY_PATHNAME","useBasename","basenameOrig","parentPathname","useResolvedLocation","attachRouteData","routesOrig","routeDataMap","map","props","fetchData","routeData","path","createRouteDataMap","matches","parentParams","forEach","match","params","getCachedRouteDataMap","basename","cache","window","__ROUTE_DATA_MAP_CACHE__","e","useRoutes","navigator","userAgent","includes","caseSensitive","useParams","useLocation","matchRoutes","Object","keys","length","assign","routes","useRoutesOrig","useListen","useState","setRouteDataMap","ref","useRef","useEffect","current","consumeCachedRouteDataMap","_ref$current2","_ref$current3","_ref$current4","prev","Routes","createRoutesFromChildren","FetchData","fetchFunc","prefetch","FetchDataLazy","factory","preparedFetcher","prepare","invokeFetcher","run","source"],"mappings":"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"}