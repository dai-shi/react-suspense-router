{"version":3,"file":"index.js","sources":["../src/types.ts","../src/RouteDataContext.ts","../src/Routes.tsx","../src/LazyFetcher.ts"],"sourcesContent":["import { ReactElement, ReactNode } from 'react';\n\ntype RouteWithElement = {\n  path: string;\n  element: ReactElement;\n  children: ReactNode;\n};\n\ntype RouteWithRedirectTo = {\n  path: string;\n  redirectTo: string;\n};\n\nexport type Route = RouteWithElement | RouteWithRedirectTo;\n\nexport const hasRouteElement = (route: Route): route is RouteWithElement => (\n  !!(route as RouteWithElement).element\n);\n\nexport type match<Params extends { [K in keyof Params]?: string } = {}> = {\n  params: Params;\n  pathname: string;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Location = any;\n","/* eslint camelcase: off */\n/* eslint @typescript-eslint/camelcase: off */\n\nimport { createContainer } from 'react-tracked';\n\nconst passDataProp = ({ data }: { data: object }) => [\n  data,\n  null, // we don't use useUpdate\n] as const;\n\nconst {\n  Provider,\n  useTrackedState,\n  useSelector,\n} = createContainer(passDataProp);\n\nexport const RouteDataProvider = Provider;\n\ntype UseTrackedState = <State>(opts: {\n  unstable_ignoreStateEquality?: boolean;\n}) => State;\n\nexport const useRouteData = () => (useTrackedState as UseTrackedState)({\n  // Because Suspendable by react-suspense-fetch is a mutable object,\n  // we need this special mode to handle it.\n  unstable_ignoreStateEquality: true,\n});\n\nexport const useRouteDataSelector = useSelector;\n","/* eslint react/no-children-prop: off */\n\nimport React, { useEffect, useState, useRef } from 'react';\nimport {\n  useParams,\n  useResolvedLocation,\n  createRoutesFromChildren,\n  useRoutes as useRoutesOrig,\n  useListen,\n  matchRoutes,\n  // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n  // @ts-ignore\n} from 'react-router';\n\nimport {\n  Route,\n  hasRouteElement,\n  match as Match,\n  Location,\n} from './types';\nimport { RouteDataProvider } from './RouteDataContext';\n\n// HACK because RouteContext is not exported.\nconst EMPTY_PATHNAME = { pathname: null };\nconst usePathname = () => useResolvedLocation(EMPTY_PATHNAME).pathname;\n\nexport const useRoutes = (\n  routesOrig: Route[],\n  basenameOrig = '',\n  caseSensitive = false,\n) => {\n  const listen = useListen();\n  const parentPathname = usePathname();\n  const parentParams = useParams();\n\n  const basename = basenameOrig\n    ? `${parentPathname}/${basenameOrig}`.replace(/\\/\\/+/g, '/')\n    : parentPathname;\n\n  const [routeDataMap, setRouteDataMap] = useState(new Map<string, object>());\n\n  const ref = useRef<{\n    routesOrig: Route[];\n    basename: string;\n    caseSensitive: boolean;\n    parentParams: { [key: string]: string };\n  }>();\n  useEffect(() => {\n    ref.current = {\n      routesOrig,\n      basename,\n      caseSensitive,\n      parentParams,\n    };\n  });\n\n  useEffect(() => {\n    let map = new Map<string, object>();\n    const unlisten = listen((location: Location) => {\n      const matches = matchRoutes(\n        ref.current?.routesOrig,\n        location,\n        ref.current?.basename,\n        ref.current?.caseSensitive,\n      );\n      map = new Map<string, object>();\n      (matches || []).forEach((match: Match & { route?: Route }) => {\n        const { params, pathname, route } = match;\n        if (!route || !hasRouteElement(route)) return;\n        const { fetchData } = route.element.props;\n        if (!fetchData) return;\n        const m: Match = {\n          params: { ...ref.current?.parentParams, ...params },\n          pathname,\n        };\n        const routeData = fetchData(m);\n        map.set(route.path, routeData);\n      });\n      setRouteDataMap((prev) => {\n        if (prev.size === 0 && map.size === 0) return prev; // bail out\n        return map;\n      });\n    });\n    return unlisten;\n  }, [listen]);\n\n  const routes = routesOrig.map((route) => {\n    if (!hasRouteElement(route)) return route;\n    const { fetchData } = route.element.props;\n    if (!fetchData) return route;\n    const routeData = routeDataMap.get(route.path);\n    return {\n      ...route,\n      element: routeData && (\n        <RouteDataProvider data={routeData} children={route.element} />\n      ),\n    };\n  });\n\n  return useRoutesOrig(routes, basenameOrig, caseSensitive);\n};\n\ntype Props = {\n  basename?: string;\n  caseSensitive?: boolean;\n};\n\nexport const Routes: React.FC<Props> = ({\n  basename = '',\n  caseSensitive = false,\n  children,\n}) => {\n  const routes = createRoutesFromChildren(children);\n  return useRoutes(routes, basename, caseSensitive);\n};\n","import { prepare, run, prefetch } from 'react-suspense-fetch';\n\nimport { match as Match } from './types';\n\nexport const LazyFetcher = <T extends object, P>(\n  factory: () => Promise<{ default: (m: Match<P>) => Promise<T> }>,\n) => {\n  const preparedFetcher = prepare(factory);\n  const invokeFetcher = async (\n    [fetcher, match]: readonly [(m: Match<P>) => Promise<T>, Match<P>],\n  ) => fetcher(match);\n  return (match: Match<P>) => {\n    run(preparedFetcher, null);\n    return prefetch(\n      invokeFetcher,\n      [preparedFetcher, match] as const,\n      (source) => [\n        source[0].default, // can suspend\n        source[1],\n      ] as const,\n    );\n  };\n};\n\nexport default LazyFetcher;\n"],"names":["hasRouteElement","route","element","createContainer","data","useTrackedState","RouteDataProvider","Provider","useRouteDataSelector","useSelector","EMPTY_PATHNAME","pathname","useRoutes","routesOrig","basenameOrig","caseSensitive","listen","useListen","parentPathname","useResolvedLocation","parentParams","useParams","basename","replace","useState","Map","routeDataMap","setRouteDataMap","ref","useRef","useEffect","current","map","location","matches","matchRoutes","_ref$current","_ref$current2","_ref$current3","forEach","match","params","fetchData","props","routeData","_ref$current4","set","path","prev","size","routes","get","React","children","useRoutesOrig","factory","preparedFetcher","prepare","invokeFetcher","fetcher","run","prefetch","source","createRoutesFromChildren","unstable_ignoreStateEquality"],"mappings":"wZAeaA,EAAkB,SAACC,WAC3BA,EAA2BC,WCF5BC,kBATiB,kBAAgC,GAA7BC,KAEtB,QAKAC,IAAAA,gBAIWC,IALXC,SAiBWC,IAfXC,YCUIC,EAAiB,CAAEC,SAAU,MAGtBC,EAAY,SACvBC,EACAC,EACAC,YADAD,IAAAA,EAAe,aACfC,IAAAA,GAAgB,GAEhB,IAAMC,EAASC,cACTC,EARkBC,sBAAoBT,GAAgBC,SAStDS,EAAeC,cAEfC,EAAWR,GACVI,MAAkBJ,GAAeS,QAAQ,SAAU,KACtDL,IAEoCM,WAAS,IAAIC,KAA9CC,OAAcC,OAEfC,EAAMC,WAMZC,YAAU,WACRF,EAAIG,QAAU,CACZlB,WAAAA,EACAS,SAAAA,EACAP,cAAAA,EACAK,aAAAA,KAIJU,YAAU,WACR,IAAIE,EAAM,IAAIP,IA0Bd,OAzBiBT,EAAO,SAACiB,aACjBC,EAAUC,uBACdP,EAAIG,gBAAJK,EAAavB,WACboB,WACAL,EAAIG,gBAAJM,EAAaf,kBACbM,EAAIG,gBAAJO,EAAavB,eAEfiB,EAAM,IAAIP,KACTS,GAAW,IAAIK,QAAQ,SAACC,SACfC,EAA4BD,EAA5BC,OAAQ9B,EAAoB6B,EAApB7B,SAAUV,EAAUuC,EAAVvC,MAC1B,GAAKA,GAAUD,EAAgBC,GAA/B,KACQyC,EAAczC,EAAMC,QAAQyC,MAA5BD,UACR,GAAKA,EAAL,CACA,IAIME,EAAYF,EAJD,CACfD,qBAAab,EAAIG,gBAAJc,EAAazB,gBAAiBqB,GAC3C9B,SAAAA,IAGFqB,EAAIc,IAAI7C,EAAM8C,KAAMH,OAEtBjB,EAAgB,SAACqB,GACf,OAAkB,IAAdA,EAAKC,MAA2B,IAAbjB,EAAIiB,KAAmBD,EACvChB,OAIV,CAAChB,IAEJ,IAAMkC,EAASrC,EAAWmB,IAAI,SAAC/B,GAC7B,IAAKD,EAAgBC,GAAQ,OAAOA,EAEpC,IADsBA,EAAMC,QAAQyC,MAA5BD,UACQ,OAAOzC,EACvB,IAAM2C,EAAYlB,EAAayB,IAAIlD,EAAM8C,MACzC,YACK9C,GACHC,QAAS0C,GACPQ,gBAAC9C,GAAkBF,KAAMwC,EAAWS,SAAUpD,EAAMC,cAK1D,OAAOoD,YAAcJ,EAAQpC,EAAcC,w3EC/FlB,SACzBwC,GAEA,IAAMC,EAAkBC,UAAQF,GAC1BG,kBACHC,OAASnB,kCACPmB,EAAQnB,wCACb,gBAAQA,GAEN,OADAoB,MAAIJ,EAAiB,MACdK,WACLH,EACA,CAACF,EAAiBhB,GAClB,SAACsB,SAAW,CACVA,EAAO,WACPA,EAAO,uBDyFwB,oBACrCxC,SAAAA,aAAW,SACXP,cAAAA,gBAGMmC,EAASa,6BAFfV,UAGA,OAAOzC,EAAUsC,EAAQ5B,EAAUP,yBD3FT,kBAAOV,EAAoC,CAGrE2D,8BAA8B"}